{"ast":null,"code":"import { InstructionType } from './instructionParser';\n\n/**\r\n * Reservation Station class\r\n * Represents a functional unit reservation station in the Tomasulo algorithm\r\n */\nexport class ReservationStation {\n  constructor(name, type) {\n    this.name = name; // Name of the reservation station\n    this.type = type; // Type of functional unit (ADD, MULT, LOAD)\n    this.busy = false; // Whether the station is currently in use\n    this.op = null; // Operation to be performed\n    this.vj = null; // First operand value\n    this.vk = null; // Second operand value\n    this.qj = null; // First operand source reservation station\n    this.qk = null; // Second operand source reservation station\n    this.dest = null; // Destination register\n    this.instruction = null; // The instruction being executed\n    this.remainingCycles = null; // Remaining execution cycles\n    this.immediate = null; // Immediate value for load instructions\n    this.executing = false; // Whether the instruction is currently executing\n  }\n\n  /**\r\n   * Clear the reservation station state\r\n   */\n  clear() {\n    this.busy = false;\n    this.op = null;\n    this.vj = null;\n    this.vk = null;\n    this.qj = null;\n    this.qk = null;\n    this.dest = null;\n    this.instruction = null;\n    this.remainingCycles = null;\n    this.immediate = null;\n    this.executing = false;\n  }\n}\n\n/**\r\n * Register Status class\r\n * Tracks the status of each register in the Tomasulo algorithm\r\n */\nexport class RegisterStatus {\n  constructor() {\n    this.value = 0; // Current value in the register\n    this.qi = null; // Reservation station producing the value\n  }\n}\n\n/**\r\n * Tomasulo Algorithm Core class\r\n * Implements the core logic of the Tomasulo algorithm for dynamic scheduling\r\n */\nexport class TomasuloCore {\n  constructor(config = {}) {\n    // Extract configuration with default values\n    const {\n      addUnits = 3,\n      multUnits = 2,\n      loadUnits = 2\n    } = config;\n\n    // Initialize registers\n    this.registers = Array(32).fill().map(() => new RegisterStatus());\n\n    // Initialize reservation stations for each functional unit type\n    this.reservationStations = {\n      add: Array(addUnits).fill().map((_, i) => new ReservationStation(`ADD${i + 1}`, 'ADD')),\n      mult: Array(multUnits).fill().map((_, i) => new ReservationStation(`MULT${i + 1}`, 'MULT')),\n      load: Array(loadUnits).fill().map((_, i) => new ReservationStation(`LOAD${i + 1}`, 'LOAD'))\n    };\n    this.instructions = []; // List of all instructions\n    this.currentCycle = 0; // Current clock cycle\n    this.instructionQueue = []; // Queue of instructions waiting to be issued\n    this.memory = new Map(); // Memory contents\n    this.executedInstructions = new Set(); // Set of completed instructions\n  }\n\n  /**\r\n   * Initialize memory with given values\r\n   * @param {Array} addresses - Array of {address, value} pairs\r\n   */\n  initializeMemory(addresses) {\n    addresses.forEach(({\n      address,\n      value\n    }) => {\n      this.memory.set(address, value);\n    });\n  }\n\n  /**\r\n   * Get an available reservation station of the specified type\r\n   * @param {string} type - Type of functional unit (ADD, MULT, LOAD)\r\n   * @returns {ReservationStation|null} Available station or null if none available\r\n   */\n  getAvailableStation(type) {\n    const stations = this.reservationStations[type.toLowerCase()];\n    return stations.find(station => !station.busy);\n  }\n\n  /**\r\n   * Issue an instruction to a reservation station\r\n   * @param {Object} instruction - The instruction to issue\r\n   * @returns {boolean} Whether the instruction was successfully issued\r\n   */\n  issue(instruction) {\n    // Check if instruction has already been executed\n    if (this.executedInstructions.has(instruction)) {\n      return false;\n    }\n\n    // Get appropriate reservation station based on instruction type\n    const station = this.getAvailableStation(instruction.type === InstructionType.ADD || instruction.type === InstructionType.SUB ? 'ADD' : instruction.type === InstructionType.MUL || instruction.type === InstructionType.DIV ? 'MULT' : 'LOAD');\n    if (!station) return false;\n\n    // Initialize reservation station\n    station.busy = true;\n    station.op = instruction.type;\n    station.instruction = instruction;\n    station.dest = instruction.dest;\n    station.immediate = instruction.immediate;\n    station.remainingCycles = null;\n\n    // Check and set first operand\n    if (instruction.src1) {\n      const reg1 = this.registers[parseInt(instruction.src1.replace('R', ''))];\n      if (reg1.qi) {\n        station.qj = reg1.qi;\n      } else {\n        station.vj = reg1.value;\n      }\n    }\n\n    // Check and set second operand\n    if (instruction.src2) {\n      const reg2 = this.registers[parseInt(instruction.src2.replace('R', ''))];\n      if (reg2.qi) {\n        station.qk = reg2.qi;\n      } else {\n        station.vk = reg2.value;\n      }\n    }\n\n    // Update destination register status\n    const destReg = this.registers[parseInt(instruction.dest.replace('R', ''))];\n    destReg.qi = station.name;\n    return true;\n  }\n\n  /**\r\n   * Execute instructions in reservation stations\r\n   */\n  execute() {\n    Object.values(this.reservationStations).flat().forEach(station => {\n      if (station.busy && !station.qj && !station.qk) {\n        if (!station.executing) {\n          // Set execution cycles based on operation type\n          switch (station.op) {\n            case InstructionType.ADD:\n            case InstructionType.SUB:\n              station.remainingCycles = 2;\n              break;\n            case InstructionType.MUL:\n              station.remainingCycles = 10;\n              break;\n            case InstructionType.DIV:\n              station.remainingCycles = 40;\n              break;\n            case InstructionType.LD:\n              station.remainingCycles = 2;\n              break;\n          }\n          station.executing = true;\n        } else if (station.remainingCycles > 0) {\n          // Decrease remaining cycles only if execution has started\n          station.remainingCycles--;\n        }\n      }\n    });\n  }\n\n  /**\r\n   * Write back results from completed instructions\r\n   */\n  writeback() {\n    Object.values(this.reservationStations).flat().forEach(station => {\n      if (station.busy && station.executing && station.remainingCycles === 0) {\n        // Calculate result based on operation type\n        let result;\n        switch (station.op) {\n          case InstructionType.ADD:\n            result = station.vj + station.vk;\n            break;\n          case InstructionType.SUB:\n            result = station.vj - station.vk;\n            break;\n          case InstructionType.MUL:\n            result = station.vj * station.vk;\n            break;\n          case InstructionType.DIV:\n            result = station.vj / station.vk;\n            break;\n          case InstructionType.LD:\n            result = this.memory.get(parseInt(station.immediate)) || 0;\n            break;\n        }\n\n        // Update destination register\n        const destReg = this.registers[parseInt(station.dest.replace('R', ''))];\n        destReg.value = result;\n        destReg.qi = null;\n\n        // Update other reservation stations waiting for this result\n        Object.values(this.reservationStations).flat().forEach(otherStation => {\n          if (otherStation.busy) {\n            let shouldStartExecution = false;\n            if (otherStation.qj === station.name) {\n              otherStation.vj = result;\n              otherStation.qj = null;\n              shouldStartExecution = true;\n            }\n            if (otherStation.qk === station.name) {\n              otherStation.vk = result;\n              otherStation.qk = null;\n              shouldStartExecution = true;\n            }\n\n            // Start execution if all operands are ready\n            if (shouldStartExecution && !otherStation.qj && !otherStation.qk && !otherStation.executing) {\n              otherStation.executing = true;\n              switch (otherStation.op) {\n                case InstructionType.ADD:\n                case InstructionType.SUB:\n                  otherStation.remainingCycles = 2;\n                  break;\n                case InstructionType.MUL:\n                  otherStation.remainingCycles = 10;\n                  break;\n                case InstructionType.DIV:\n                  otherStation.remainingCycles = 40;\n                  break;\n                case InstructionType.LD:\n                  otherStation.remainingCycles = 2;\n                  break;\n              }\n            }\n          }\n        });\n\n        // Mark instruction as executed\n        if (station.instruction) {\n          this.executedInstructions.add(station.instruction);\n        }\n        station.clear();\n      }\n    });\n  }\n\n  /**\r\n   * Execute one cycle of the Tomasulo algorithm\r\n   */\n  step() {\n    this.currentCycle++;\n\n    // Try to issue new instruction\n    if (this.instructionQueue.length > 0) {\n      const nextInstruction = this.instructionQueue[0];\n      if (this.issue(nextInstruction)) {\n        this.instructionQueue.shift();\n      }\n    }\n    this.execute();\n    this.writeback();\n  }\n\n  /**\r\n   * Reset the simulator to initial state\r\n   */\n  reset() {\n    this.registers = Array(32).fill().map(() => new RegisterStatus());\n    Object.values(this.reservationStations).flat().forEach(station => station.clear());\n    this.currentCycle = 0;\n    this.instructionQueue = [];\n    this.executedInstructions.clear();\n  }\n\n  /**\r\n   * Load instructions into the instruction queue\r\n   * @param {Array} instructions - Array of instructions to load\r\n   */\n  loadInstructions(instructions) {\n    this.instructionQueue = [...instructions];\n  }\n\n  /**\r\n   * Get current memory contents\r\n   * @returns {Array} Array of {address, value} pairs\r\n   */\n  getMemoryContents() {\n    return Array.from(this.memory.entries()).map(([address, value]) => ({\n      address,\n      value\n    }));\n  }\n}","map":{"version":3,"names":["InstructionType","ReservationStation","constructor","name","type","busy","op","vj","vk","qj","qk","dest","instruction","remainingCycles","immediate","executing","clear","RegisterStatus","value","qi","TomasuloCore","config","addUnits","multUnits","loadUnits","registers","Array","fill","map","reservationStations","add","_","i","mult","load","instructions","currentCycle","instructionQueue","memory","Map","executedInstructions","Set","initializeMemory","addresses","forEach","address","set","getAvailableStation","stations","toLowerCase","find","station","issue","has","ADD","SUB","MUL","DIV","src1","reg1","parseInt","replace","src2","reg2","destReg","execute","Object","values","flat","LD","writeback","result","get","otherStation","shouldStartExecution","step","length","nextInstruction","shift","reset","loadInstructions","getMemoryContents","from","entries"],"sources":["D:/vscode/Tomasulo/src/utils/tomasuloCore.js"],"sourcesContent":["import { InstructionType } from './instructionParser';\r\n\r\n/**\r\n * Reservation Station class\r\n * Represents a functional unit reservation station in the Tomasulo algorithm\r\n */\r\nexport class ReservationStation {\r\n  constructor(name, type) {\r\n    this.name = name;          // Name of the reservation station\r\n    this.type = type;          // Type of functional unit (ADD, MULT, LOAD)\r\n    this.busy = false;         // Whether the station is currently in use\r\n    this.op = null;            // Operation to be performed\r\n    this.vj = null;            // First operand value\r\n    this.vk = null;            // Second operand value\r\n    this.qj = null;            // First operand source reservation station\r\n    this.qk = null;            // Second operand source reservation station\r\n    this.dest = null;          // Destination register\r\n    this.instruction = null;   // The instruction being executed\r\n    this.remainingCycles = null; // Remaining execution cycles\r\n    this.immediate = null;     // Immediate value for load instructions\r\n    this.executing = false;    // Whether the instruction is currently executing\r\n  }\r\n\r\n  /**\r\n   * Clear the reservation station state\r\n   */\r\n  clear() {\r\n    this.busy = false;\r\n    this.op = null;\r\n    this.vj = null;\r\n    this.vk = null;\r\n    this.qj = null;\r\n    this.qk = null;\r\n    this.dest = null;\r\n    this.instruction = null;\r\n    this.remainingCycles = null;\r\n    this.immediate = null;\r\n    this.executing = false;\r\n  }\r\n}\r\n\r\n/**\r\n * Register Status class\r\n * Tracks the status of each register in the Tomasulo algorithm\r\n */\r\nexport class RegisterStatus {\r\n  constructor() {\r\n    this.value = 0;    // Current value in the register\r\n    this.qi = null;    // Reservation station producing the value\r\n  }\r\n}\r\n\r\n/**\r\n * Tomasulo Algorithm Core class\r\n * Implements the core logic of the Tomasulo algorithm for dynamic scheduling\r\n */\r\nexport class TomasuloCore {\r\n  constructor(config = {}) {\r\n    // Extract configuration with default values\r\n    const { addUnits = 3, multUnits = 2, loadUnits = 2 } = config;\r\n    \r\n    // Initialize registers\r\n    this.registers = Array(32).fill().map(() => new RegisterStatus());\r\n    \r\n    // Initialize reservation stations for each functional unit type\r\n    this.reservationStations = {\r\n      add: Array(addUnits).fill().map((_, i) => new ReservationStation(`ADD${i + 1}`, 'ADD')),\r\n      mult: Array(multUnits).fill().map((_, i) => new ReservationStation(`MULT${i + 1}`, 'MULT')),\r\n      load: Array(loadUnits).fill().map((_, i) => new ReservationStation(`LOAD${i + 1}`, 'LOAD'))\r\n    };\r\n    \r\n    this.instructions = [];           // List of all instructions\r\n    this.currentCycle = 0;           // Current clock cycle\r\n    this.instructionQueue = [];       // Queue of instructions waiting to be issued\r\n    this.memory = new Map();         // Memory contents\r\n    this.executedInstructions = new Set(); // Set of completed instructions\r\n  }\r\n\r\n  /**\r\n   * Initialize memory with given values\r\n   * @param {Array} addresses - Array of {address, value} pairs\r\n   */\r\n  initializeMemory(addresses) {\r\n    addresses.forEach(({ address, value }) => {\r\n      this.memory.set(address, value);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get an available reservation station of the specified type\r\n   * @param {string} type - Type of functional unit (ADD, MULT, LOAD)\r\n   * @returns {ReservationStation|null} Available station or null if none available\r\n   */\r\n  getAvailableStation(type) {\r\n    const stations = this.reservationStations[type.toLowerCase()];\r\n    return stations.find(station => !station.busy);\r\n  }\r\n\r\n  /**\r\n   * Issue an instruction to a reservation station\r\n   * @param {Object} instruction - The instruction to issue\r\n   * @returns {boolean} Whether the instruction was successfully issued\r\n   */\r\n  issue(instruction) {\r\n    // Check if instruction has already been executed\r\n    if (this.executedInstructions.has(instruction)) {\r\n      return false;\r\n    }\r\n\r\n    // Get appropriate reservation station based on instruction type\r\n    const station = this.getAvailableStation(\r\n      instruction.type === InstructionType.ADD || instruction.type === InstructionType.SUB\r\n        ? 'ADD'\r\n        : instruction.type === InstructionType.MUL || instruction.type === InstructionType.DIV\r\n        ? 'MULT'\r\n        : 'LOAD'\r\n    );\r\n\r\n    if (!station) return false;\r\n\r\n    // Initialize reservation station\r\n    station.busy = true;\r\n    station.op = instruction.type;\r\n    station.instruction = instruction;\r\n    station.dest = instruction.dest;\r\n    station.immediate = instruction.immediate;\r\n    station.remainingCycles = null;\r\n\r\n    // Check and set first operand\r\n    if (instruction.src1) {\r\n      const reg1 = this.registers[parseInt(instruction.src1.replace('R', ''))];\r\n      if (reg1.qi) {\r\n        station.qj = reg1.qi;\r\n      } else {\r\n        station.vj = reg1.value;\r\n      }\r\n    }\r\n\r\n    // Check and set second operand\r\n    if (instruction.src2) {\r\n      const reg2 = this.registers[parseInt(instruction.src2.replace('R', ''))];\r\n      if (reg2.qi) {\r\n        station.qk = reg2.qi;\r\n      } else {\r\n        station.vk = reg2.value;\r\n      }\r\n    }\r\n\r\n    // Update destination register status\r\n    const destReg = this.registers[parseInt(instruction.dest.replace('R', ''))];\r\n    destReg.qi = station.name;\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Execute instructions in reservation stations\r\n   */\r\n  execute() {\r\n    Object.values(this.reservationStations).flat().forEach(station => {\r\n      if (station.busy && !station.qj && !station.qk) {\r\n        if (!station.executing) {\r\n          // Set execution cycles based on operation type\r\n          switch (station.op) {\r\n            case InstructionType.ADD:\r\n            case InstructionType.SUB:\r\n              station.remainingCycles = 2;\r\n              break;\r\n            case InstructionType.MUL:\r\n              station.remainingCycles = 10;\r\n              break;\r\n            case InstructionType.DIV:\r\n              station.remainingCycles = 40;\r\n              break;\r\n            case InstructionType.LD:\r\n              station.remainingCycles = 2;\r\n              break;\r\n          }\r\n          station.executing = true;\r\n        } else if (station.remainingCycles > 0) {\r\n          // Decrease remaining cycles only if execution has started\r\n          station.remainingCycles--;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Write back results from completed instructions\r\n   */\r\n  writeback() {\r\n    Object.values(this.reservationStations).flat().forEach(station => {\r\n      if (station.busy && station.executing && station.remainingCycles === 0) {\r\n        // Calculate result based on operation type\r\n        let result;\r\n        switch (station.op) {\r\n          case InstructionType.ADD:\r\n            result = station.vj + station.vk;\r\n            break;\r\n          case InstructionType.SUB:\r\n            result = station.vj - station.vk;\r\n            break;\r\n          case InstructionType.MUL:\r\n            result = station.vj * station.vk;\r\n            break;\r\n          case InstructionType.DIV:\r\n            result = station.vj / station.vk;\r\n            break;\r\n          case InstructionType.LD:\r\n            result = this.memory.get(parseInt(station.immediate)) || 0;\r\n            break;\r\n        }\r\n\r\n        // Update destination register\r\n        const destReg = this.registers[parseInt(station.dest.replace('R', ''))];\r\n        destReg.value = result;\r\n        destReg.qi = null;\r\n\r\n        // Update other reservation stations waiting for this result\r\n        Object.values(this.reservationStations).flat().forEach(otherStation => {\r\n          if (otherStation.busy) {\r\n            let shouldStartExecution = false;\r\n            if (otherStation.qj === station.name) {\r\n              otherStation.vj = result;\r\n              otherStation.qj = null;\r\n              shouldStartExecution = true;\r\n            }\r\n            if (otherStation.qk === station.name) {\r\n              otherStation.vk = result;\r\n              otherStation.qk = null;\r\n              shouldStartExecution = true;\r\n            }\r\n            \r\n            // Start execution if all operands are ready\r\n            if (shouldStartExecution && !otherStation.qj && !otherStation.qk && !otherStation.executing) {\r\n              otherStation.executing = true;\r\n              switch (otherStation.op) {\r\n                case InstructionType.ADD:\r\n                case InstructionType.SUB:\r\n                  otherStation.remainingCycles = 2;\r\n                  break;\r\n                case InstructionType.MUL:\r\n                  otherStation.remainingCycles = 10;\r\n                  break;\r\n                case InstructionType.DIV:\r\n                  otherStation.remainingCycles = 40;\r\n                  break;\r\n                case InstructionType.LD:\r\n                  otherStation.remainingCycles = 2;\r\n                  break;\r\n              }\r\n            }\r\n          }\r\n        });\r\n\r\n        // Mark instruction as executed\r\n        if (station.instruction) {\r\n          this.executedInstructions.add(station.instruction);\r\n        }\r\n\r\n        station.clear();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Execute one cycle of the Tomasulo algorithm\r\n   */\r\n  step() {\r\n    this.currentCycle++;\r\n    \r\n    // Try to issue new instruction\r\n    if (this.instructionQueue.length > 0) {\r\n      const nextInstruction = this.instructionQueue[0];\r\n      if (this.issue(nextInstruction)) {\r\n        this.instructionQueue.shift();\r\n      }\r\n    }\r\n\r\n    this.execute();\r\n    this.writeback();\r\n  }\r\n\r\n  /**\r\n   * Reset the simulator to initial state\r\n   */\r\n  reset() {\r\n    this.registers = Array(32).fill().map(() => new RegisterStatus());\r\n    Object.values(this.reservationStations).flat().forEach(station => station.clear());\r\n    this.currentCycle = 0;\r\n    this.instructionQueue = [];\r\n    this.executedInstructions.clear();\r\n  }\r\n\r\n  /**\r\n   * Load instructions into the instruction queue\r\n   * @param {Array} instructions - Array of instructions to load\r\n   */\r\n  loadInstructions(instructions) {\r\n    this.instructionQueue = [...instructions];\r\n  }\r\n\r\n  /**\r\n   * Get current memory contents\r\n   * @returns {Array} Array of {address, value} pairs\r\n   */\r\n  getMemoryContents() {\r\n    return Array.from(this.memory.entries()).map(([address, value]) => ({\r\n      address,\r\n      value\r\n    }));\r\n  }\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}