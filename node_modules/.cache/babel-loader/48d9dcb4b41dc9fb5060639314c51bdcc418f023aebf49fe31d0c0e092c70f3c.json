{"ast":null,"code":"import{InstructionType}from'./instructionParser';/**\r\n * Reservation Station class\r\n * Represents a functional unit reservation station in the Tomasulo algorithm\r\n */export class ReservationStation{constructor(name,type){this.name=name;// Name of the reservation station\nthis.type=type;// Type of functional unit (ADD, MULT, LOAD)\nthis.busy=false;// Whether the station is currently in use\nthis.op=null;// Operation to be performed\nthis.vj=null;// First operand value\nthis.vk=null;// Second operand value\nthis.qj=null;// First operand source reservation station\nthis.qk=null;// Second operand source reservation station\nthis.dest=null;// Destination register\nthis.instruction=null;// The instruction being executed\nthis.remainingCycles=null;// Remaining execution cycles\nthis.immediate=null;// Immediate value for load instructions\nthis.executing=false;// Whether the instruction is currently executing\n}/**\r\n   * Clear the reservation station state\r\n   */clear(){this.busy=false;this.op=null;this.vj=null;this.vk=null;this.qj=null;this.qk=null;this.dest=null;this.instruction=null;this.remainingCycles=null;this.immediate=null;this.executing=false;}}/**\r\n * Register Status class\r\n * Tracks the status of each register in the Tomasulo algorithm\r\n */export class RegisterStatus{constructor(){this.value=0;// Current value in the register\nthis.qi=null;// Reservation station producing the value\n}}/**\r\n * Tomasulo Algorithm Core class\r\n * Implements the core logic of the Tomasulo algorithm for dynamic scheduling\r\n */export class TomasuloCore{constructor(){let config=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};// Extract configuration with default values\nconst{addUnits=3,multUnits=2,loadUnits=2}=config;// Initialize registers\nthis.registers=Array(32).fill().map(()=>new RegisterStatus());// Initialize reservation stations for each functional unit type\nthis.reservationStations={add:Array(addUnits).fill().map((_,i)=>new ReservationStation(\"ADD\".concat(i+1),'ADD')),mult:Array(multUnits).fill().map((_,i)=>new ReservationStation(\"MULT\".concat(i+1),'MULT')),load:Array(loadUnits).fill().map((_,i)=>new ReservationStation(\"LOAD\".concat(i+1),'LOAD'))};this.instructions=[];// List of all instructions\nthis.currentCycle=0;// Current clock cycle\nthis.instructionQueue=[];// Queue of instructions waiting to be issued\nthis.memory=new Map();// Memory contents\nthis.executedInstructions=new Set();// Set of completed instructions\n}/**\r\n   * Initialize memory with given values\r\n   * @param {Array} addresses - Array of {address, value} pairs\r\n   */initializeMemory(addresses){addresses.forEach(_ref=>{let{address,value}=_ref;this.memory.set(address,value);});}/**\r\n   * Get an available reservation station of the specified type\r\n   * @param {string} type - Type of functional unit (ADD, MULT, LOAD)\r\n   * @returns {ReservationStation|null} Available station or null if none available\r\n   */getAvailableStation(type){const stations=this.reservationStations[type.toLowerCase()];return stations.find(station=>!station.busy);}/**\r\n   * Issue an instruction to a reservation station\r\n   * @param {Object} instruction - The instruction to issue\r\n   * @returns {boolean} Whether the instruction was successfully issued\r\n   */issue(instruction){// Check if instruction has already been executed\nif(this.executedInstructions.has(instruction)){return false;}// Get appropriate reservation station based on instruction type\nconst station=this.getAvailableStation(instruction.type===InstructionType.ADD||instruction.type===InstructionType.SUB?'ADD':instruction.type===InstructionType.MUL||instruction.type===InstructionType.DIV?'MULT':'LOAD');if(!station)return false;// Initialize reservation station\nstation.busy=true;station.op=instruction.type;station.instruction=instruction;station.dest=instruction.dest;station.immediate=instruction.immediate;station.remainingCycles=null;// Check and set first operand\nif(instruction.src1){const reg1=this.registers[parseInt(instruction.src1.replace('R',''))];if(reg1.qi){station.qj=reg1.qi;}else{station.vj=reg1.value;}}// Check and set second operand\nif(instruction.src2){const reg2=this.registers[parseInt(instruction.src2.replace('R',''))];if(reg2.qi){station.qk=reg2.qi;}else{station.vk=reg2.value;}}// Update destination register status\nconst destReg=this.registers[parseInt(instruction.dest.replace('R',''))];destReg.qi=station.name;return true;}/**\r\n   * Execute instructions in reservation stations\r\n   */execute(){Object.values(this.reservationStations).flat().forEach(station=>{if(station.busy&&!station.qj&&!station.qk){if(!station.executing){// Set execution cycles based on operation type\nswitch(station.op){case InstructionType.ADD:case InstructionType.SUB:station.remainingCycles=2;break;case InstructionType.MUL:station.remainingCycles=10;break;case InstructionType.DIV:station.remainingCycles=40;break;case InstructionType.LD:station.remainingCycles=2;break;}station.executing=true;}else if(station.remainingCycles>0){// Decrease remaining cycles only if execution has started\nstation.remainingCycles--;}}});}/**\r\n   * Write back results from completed instructions\r\n   */writeback(){Object.values(this.reservationStations).flat().forEach(station=>{if(station.busy&&station.executing&&station.remainingCycles===0){// Calculate result based on operation type\nlet result;switch(station.op){case InstructionType.ADD:result=station.vj+station.vk;break;case InstructionType.SUB:result=station.vj-station.vk;break;case InstructionType.MUL:result=station.vj*station.vk;break;case InstructionType.DIV:result=station.vj/station.vk;break;case InstructionType.LD:result=this.memory.get(parseInt(station.immediate))||0;break;}// Update destination register\nconst destReg=this.registers[parseInt(station.dest.replace('R',''))];destReg.value=result;destReg.qi=null;// Update other reservation stations waiting for this result\nObject.values(this.reservationStations).flat().forEach(otherStation=>{if(otherStation.busy){let shouldStartExecution=false;if(otherStation.qj===station.name){otherStation.vj=result;otherStation.qj=null;shouldStartExecution=true;}if(otherStation.qk===station.name){otherStation.vk=result;otherStation.qk=null;shouldStartExecution=true;}// Start execution if all operands are ready\nif(shouldStartExecution&&!otherStation.qj&&!otherStation.qk&&!otherStation.executing){otherStation.executing=true;switch(otherStation.op){case InstructionType.ADD:case InstructionType.SUB:otherStation.remainingCycles=2;break;case InstructionType.MUL:otherStation.remainingCycles=10;break;case InstructionType.DIV:otherStation.remainingCycles=40;break;case InstructionType.LD:otherStation.remainingCycles=2;break;}}}});// Mark instruction as executed\nif(station.instruction){this.executedInstructions.add(station.instruction);}station.clear();}});}/**\r\n   * Execute one cycle of the Tomasulo algorithm\r\n   */step(){this.currentCycle++;// Try to issue new instruction\nif(this.instructionQueue.length>0){const nextInstruction=this.instructionQueue[0];if(this.issue(nextInstruction)){this.instructionQueue.shift();}}this.execute();this.writeback();}/**\r\n   * Reset the simulator to initial state\r\n   */reset(){this.registers=Array(32).fill().map(()=>new RegisterStatus());Object.values(this.reservationStations).flat().forEach(station=>station.clear());this.currentCycle=0;this.instructionQueue=[];this.executedInstructions.clear();}/**\r\n   * Load instructions into the instruction queue\r\n   * @param {Array} instructions - Array of instructions to load\r\n   */loadInstructions(instructions){this.instructionQueue=[...instructions];}/**\r\n   * Get current memory contents\r\n   * @returns {Array} Array of {address, value} pairs\r\n   */getMemoryContents(){return Array.from(this.memory.entries()).map(_ref2=>{let[address,value]=_ref2;return{address,value};});}}","map":{"version":3,"names":["InstructionType","ReservationStation","constructor","name","type","busy","op","vj","vk","qj","qk","dest","instruction","remainingCycles","immediate","executing","clear","RegisterStatus","value","qi","TomasuloCore","config","arguments","length","undefined","addUnits","multUnits","loadUnits","registers","Array","fill","map","reservationStations","add","_","i","concat","mult","load","instructions","currentCycle","instructionQueue","memory","Map","executedInstructions","Set","initializeMemory","addresses","forEach","_ref","address","set","getAvailableStation","stations","toLowerCase","find","station","issue","has","ADD","SUB","MUL","DIV","src1","reg1","parseInt","replace","src2","reg2","destReg","execute","Object","values","flat","LD","writeback","result","get","otherStation","shouldStartExecution","step","nextInstruction","shift","reset","loadInstructions","getMemoryContents","from","entries","_ref2"],"sources":["D:/vscode/Tomasulo/src/utils/tomasuloCore.js"],"sourcesContent":["import { InstructionType } from './instructionParser';\r\n\r\n/**\r\n * Reservation Station class\r\n * Represents a functional unit reservation station in the Tomasulo algorithm\r\n */\r\nexport class ReservationStation {\r\n  constructor(name, type) {\r\n    this.name = name;          // Name of the reservation station\r\n    this.type = type;          // Type of functional unit (ADD, MULT, LOAD)\r\n    this.busy = false;         // Whether the station is currently in use\r\n    this.op = null;            // Operation to be performed\r\n    this.vj = null;            // First operand value\r\n    this.vk = null;            // Second operand value\r\n    this.qj = null;            // First operand source reservation station\r\n    this.qk = null;            // Second operand source reservation station\r\n    this.dest = null;          // Destination register\r\n    this.instruction = null;   // The instruction being executed\r\n    this.remainingCycles = null; // Remaining execution cycles\r\n    this.immediate = null;     // Immediate value for load instructions\r\n    this.executing = false;    // Whether the instruction is currently executing\r\n  }\r\n\r\n  /**\r\n   * Clear the reservation station state\r\n   */\r\n  clear() {\r\n    this.busy = false;\r\n    this.op = null;\r\n    this.vj = null;\r\n    this.vk = null;\r\n    this.qj = null;\r\n    this.qk = null;\r\n    this.dest = null;\r\n    this.instruction = null;\r\n    this.remainingCycles = null;\r\n    this.immediate = null;\r\n    this.executing = false;\r\n  }\r\n}\r\n\r\n/**\r\n * Register Status class\r\n * Tracks the status of each register in the Tomasulo algorithm\r\n */\r\nexport class RegisterStatus {\r\n  constructor() {\r\n    this.value = 0;    // Current value in the register\r\n    this.qi = null;    // Reservation station producing the value\r\n  }\r\n}\r\n\r\n/**\r\n * Tomasulo Algorithm Core class\r\n * Implements the core logic of the Tomasulo algorithm for dynamic scheduling\r\n */\r\nexport class TomasuloCore {\r\n  constructor(config = {}) {\r\n    // Extract configuration with default values\r\n    const { addUnits = 3, multUnits = 2, loadUnits = 2 } = config;\r\n    \r\n    // Initialize registers\r\n    this.registers = Array(32).fill().map(() => new RegisterStatus());\r\n    \r\n    // Initialize reservation stations for each functional unit type\r\n    this.reservationStations = {\r\n      add: Array(addUnits).fill().map((_, i) => new ReservationStation(`ADD${i + 1}`, 'ADD')),\r\n      mult: Array(multUnits).fill().map((_, i) => new ReservationStation(`MULT${i + 1}`, 'MULT')),\r\n      load: Array(loadUnits).fill().map((_, i) => new ReservationStation(`LOAD${i + 1}`, 'LOAD'))\r\n    };\r\n    \r\n    this.instructions = [];           // List of all instructions\r\n    this.currentCycle = 0;           // Current clock cycle\r\n    this.instructionQueue = [];       // Queue of instructions waiting to be issued\r\n    this.memory = new Map();         // Memory contents\r\n    this.executedInstructions = new Set(); // Set of completed instructions\r\n  }\r\n\r\n  /**\r\n   * Initialize memory with given values\r\n   * @param {Array} addresses - Array of {address, value} pairs\r\n   */\r\n  initializeMemory(addresses) {\r\n    addresses.forEach(({ address, value }) => {\r\n      this.memory.set(address, value);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get an available reservation station of the specified type\r\n   * @param {string} type - Type of functional unit (ADD, MULT, LOAD)\r\n   * @returns {ReservationStation|null} Available station or null if none available\r\n   */\r\n  getAvailableStation(type) {\r\n    const stations = this.reservationStations[type.toLowerCase()];\r\n    return stations.find(station => !station.busy);\r\n  }\r\n\r\n  /**\r\n   * Issue an instruction to a reservation station\r\n   * @param {Object} instruction - The instruction to issue\r\n   * @returns {boolean} Whether the instruction was successfully issued\r\n   */\r\n  issue(instruction) {\r\n    // Check if instruction has already been executed\r\n    if (this.executedInstructions.has(instruction)) {\r\n      return false;\r\n    }\r\n\r\n    // Get appropriate reservation station based on instruction type\r\n    const station = this.getAvailableStation(\r\n      instruction.type === InstructionType.ADD || instruction.type === InstructionType.SUB\r\n        ? 'ADD'\r\n        : instruction.type === InstructionType.MUL || instruction.type === InstructionType.DIV\r\n        ? 'MULT'\r\n        : 'LOAD'\r\n    );\r\n\r\n    if (!station) return false;\r\n\r\n    // Initialize reservation station\r\n    station.busy = true;\r\n    station.op = instruction.type;\r\n    station.instruction = instruction;\r\n    station.dest = instruction.dest;\r\n    station.immediate = instruction.immediate;\r\n    station.remainingCycles = null;\r\n\r\n    // Check and set first operand\r\n    if (instruction.src1) {\r\n      const reg1 = this.registers[parseInt(instruction.src1.replace('R', ''))];\r\n      if (reg1.qi) {\r\n        station.qj = reg1.qi;\r\n      } else {\r\n        station.vj = reg1.value;\r\n      }\r\n    }\r\n\r\n    // Check and set second operand\r\n    if (instruction.src2) {\r\n      const reg2 = this.registers[parseInt(instruction.src2.replace('R', ''))];\r\n      if (reg2.qi) {\r\n        station.qk = reg2.qi;\r\n      } else {\r\n        station.vk = reg2.value;\r\n      }\r\n    }\r\n\r\n    // Update destination register status\r\n    const destReg = this.registers[parseInt(instruction.dest.replace('R', ''))];\r\n    destReg.qi = station.name;\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Execute instructions in reservation stations\r\n   */\r\n  execute() {\r\n    Object.values(this.reservationStations).flat().forEach(station => {\r\n      if (station.busy && !station.qj && !station.qk) {\r\n        if (!station.executing) {\r\n          // Set execution cycles based on operation type\r\n          switch (station.op) {\r\n            case InstructionType.ADD:\r\n            case InstructionType.SUB:\r\n              station.remainingCycles = 2;\r\n              break;\r\n            case InstructionType.MUL:\r\n              station.remainingCycles = 10;\r\n              break;\r\n            case InstructionType.DIV:\r\n              station.remainingCycles = 40;\r\n              break;\r\n            case InstructionType.LD:\r\n              station.remainingCycles = 2;\r\n              break;\r\n          }\r\n          station.executing = true;\r\n        } else if (station.remainingCycles > 0) {\r\n          // Decrease remaining cycles only if execution has started\r\n          station.remainingCycles--;\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Write back results from completed instructions\r\n   */\r\n  writeback() {\r\n    Object.values(this.reservationStations).flat().forEach(station => {\r\n      if (station.busy && station.executing && station.remainingCycles === 0) {\r\n        // Calculate result based on operation type\r\n        let result;\r\n        switch (station.op) {\r\n          case InstructionType.ADD:\r\n            result = station.vj + station.vk;\r\n            break;\r\n          case InstructionType.SUB:\r\n            result = station.vj - station.vk;\r\n            break;\r\n          case InstructionType.MUL:\r\n            result = station.vj * station.vk;\r\n            break;\r\n          case InstructionType.DIV:\r\n            result = station.vj / station.vk;\r\n            break;\r\n          case InstructionType.LD:\r\n            result = this.memory.get(parseInt(station.immediate)) || 0;\r\n            break;\r\n        }\r\n\r\n        // Update destination register\r\n        const destReg = this.registers[parseInt(station.dest.replace('R', ''))];\r\n        destReg.value = result;\r\n        destReg.qi = null;\r\n\r\n        // Update other reservation stations waiting for this result\r\n        Object.values(this.reservationStations).flat().forEach(otherStation => {\r\n          if (otherStation.busy) {\r\n            let shouldStartExecution = false;\r\n            if (otherStation.qj === station.name) {\r\n              otherStation.vj = result;\r\n              otherStation.qj = null;\r\n              shouldStartExecution = true;\r\n            }\r\n            if (otherStation.qk === station.name) {\r\n              otherStation.vk = result;\r\n              otherStation.qk = null;\r\n              shouldStartExecution = true;\r\n            }\r\n            \r\n            // Start execution if all operands are ready\r\n            if (shouldStartExecution && !otherStation.qj && !otherStation.qk && !otherStation.executing) {\r\n              otherStation.executing = true;\r\n              switch (otherStation.op) {\r\n                case InstructionType.ADD:\r\n                case InstructionType.SUB:\r\n                  otherStation.remainingCycles = 2;\r\n                  break;\r\n                case InstructionType.MUL:\r\n                  otherStation.remainingCycles = 10;\r\n                  break;\r\n                case InstructionType.DIV:\r\n                  otherStation.remainingCycles = 40;\r\n                  break;\r\n                case InstructionType.LD:\r\n                  otherStation.remainingCycles = 2;\r\n                  break;\r\n              }\r\n            }\r\n          }\r\n        });\r\n\r\n        // Mark instruction as executed\r\n        if (station.instruction) {\r\n          this.executedInstructions.add(station.instruction);\r\n        }\r\n\r\n        station.clear();\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Execute one cycle of the Tomasulo algorithm\r\n   */\r\n  step() {\r\n    this.currentCycle++;\r\n    \r\n    // Try to issue new instruction\r\n    if (this.instructionQueue.length > 0) {\r\n      const nextInstruction = this.instructionQueue[0];\r\n      if (this.issue(nextInstruction)) {\r\n        this.instructionQueue.shift();\r\n      }\r\n    }\r\n\r\n    this.execute();\r\n    this.writeback();\r\n  }\r\n\r\n  /**\r\n   * Reset the simulator to initial state\r\n   */\r\n  reset() {\r\n    this.registers = Array(32).fill().map(() => new RegisterStatus());\r\n    Object.values(this.reservationStations).flat().forEach(station => station.clear());\r\n    this.currentCycle = 0;\r\n    this.instructionQueue = [];\r\n    this.executedInstructions.clear();\r\n  }\r\n\r\n  /**\r\n   * Load instructions into the instruction queue\r\n   * @param {Array} instructions - Array of instructions to load\r\n   */\r\n  loadInstructions(instructions) {\r\n    this.instructionQueue = [...instructions];\r\n  }\r\n\r\n  /**\r\n   * Get current memory contents\r\n   * @returns {Array} Array of {address, value} pairs\r\n   */\r\n  getMemoryContents() {\r\n    return Array.from(this.memory.entries()).map(([address, value]) => ({\r\n      address,\r\n      value\r\n    }));\r\n  }\r\n} "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}